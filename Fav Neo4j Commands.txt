//LOAD PROJECT
LOAD CSV WITH HEADERS FROM 'file:///Project_Data.csv' AS row
MERGE (pd:Project {projectNo: row.projectNo})
  ON CREATE SET pd.customerID = row. customerID, pd.personInCharge = row.personInCharge, pd.contactTitle = row.contactTitle, pd.address = row.address, pd.phoneNo = row.phone, pd.plotSize = row.plotSize, pd.license = row.license, pd.progress = row.progress, pd.distance_DZ1800K = toInteger(row.distance_DZ1800K), pd.distance_DK1829B = toInteger(row.distance_DK1829B), pd.distance_DK1837A = toInteger(row.distance_DK1837A), pd.distance_DZ7382K = toInteger(row.distance_DZ7382K);

//LOAD SITE WORKER DATA
LOAD CSV WITH HEADERS FROM 'file:///Site_Worker_Data.csv' AS row
MERGE (worker:siteWorker {workerID: row.workerID})
  ON CREATE SET worker.Name = row.Name, worker.jobTitle = row.jobTitle, worker.license1 = row.license1, worker.license2 = row.license2, worker.noLicense = row.noLicense, worker.shift = row.shift, worker.level = row.level, worker.projectNo = row.projectNo, worker.availability = row.availability;

A. Import NODES

//LOAD DEPOT WORKER DATA
LOAD CSV WITH HEADERS FROM 'file:///Depot_Worker_Data.csv' AS row
MERGE (worker:depotWorker {workerID: row.workerID})
  ON CREATE SET worker.Name = row.Name, worker.jobTitle = row.jobTitle, worker.license1 = row.license1, worker.license2 = row.license2, worker.noLicense = row.noLicense, worker.shift = row.shift, worker.level = row.level, worker.availability = row.availability;

//LOAD TRANSPORT WORKER DATA
LOAD CSV WITH HEADERS FROM 'file:///Transport_Worker_Data.csv' AS row
MERGE (worker:transportWorker {workerID: row.workerID})
  ON CREATE SET worker.Name = row.Name, worker.jobTitle = row.jobTitle, worker.license1 = row.license1, worker.license2 = row.license2, worker.noLicense = row.noLicense, worker.shift = row.shift, worker.level = row.level, worker.availability = row.availability;

//LOAD ORDER
LOAD CSV WITH HEADERS FROM 'file:///Order_Data.csv' AS row
MERGE (o:Order {orderNo: row.orderNo})
  ON CREATE SET o.customerID = row.customerID, o.projectNo = row.projectNo, o.orderDate = row.orderDate, o.requiredDate = row.requiredDate, o.truck = row.truck, o.productID = row.productID, o.quantity = row.quantity, o.reqLoading = row.reqLoading, o.reqTransport = row.reqTransport, o.reqUnload = row.Unload ;

//CREATE TRANSPORT HUB NODE
MERGE (tr:Transport {transportHub: 698128})
//Creates a node to indicate worker is a working on transport

//CREATE DEPOT HUB NODE
MERGE (dp:Depot {address:471000})

//ORDERS FROM PROJECTS
LOAD CSV WITH HEADERS FROM 'file:///Order_Data.csv' AS row

MATCH (order:Order {orderNo: row.orderNo})
MATCH (project:Project {projectNo: row.projectNo})
MERGE (order)-[:ordered_by]->(project)

//SITE WORKERS CURRENTLY WORKING AT RELATIONSHIP
LOAD CSV WITH HEADERS FROM 'file:///Site_Worker_Data.csv' AS row

MATCH (sw:siteWorker {workerID: row.workerID})
MATCH (project:Project {projectNo: row.projectNo})
MERGE (sw)-[:working_at]->(project)

##### IDENTIFY DELAYS #####

//LOAD ORDER TO ADD PRIORITY AND QUE
LOAD CSV WITH HEADERS FROM 'file:///Delayed_Order.csv' AS row
MERGE (o:Order {orderNo: row.orderNo})
  SET o.Que = row.Que;


##### CREATE UNIQUENESS #####


#####Example of Relationship generation######
Relationship is generated by linking of unique properties of nodes. In this case, the unique properties of worker nodes are workerID. 
The purpose of relationship CSV is to tell Neo4j that there is a relationship between worker1 and worker2.
User will then have to tell Neo4j what kind of relationship this is. In this example, the relationship is 'Shift_Overlap'.

<<<<<<< leroyBranch



//DEPOT WORKERS CURRENTLY WORKING AT RELATIONSHIP
MATCH (dw:depotWorker)
MATCH (dp:Depot)
MERGE (dw)-[:working_at]->(dp)


//TRANSPORT WORKERS CURRENTLY WORKING AT RELATIONSHIP
MATCH (tw:transportWorker)
MATCH (tr:Transport)
MERGE (tw)-[:working_at]->(tr)




//DEPOT WORKERS WHO MEET REQUIREMENT
LOAD CSV WITH HEADERS FROM 'file:///Depot_Meet_Req.csv' AS row

MATCH (worker:depotWorker {workerID: row.workerID})
MATCH (order:Order {orderNo: row.orderNo})
MERGE (worker)-[:Meets_Req]->(order);


//SITE WORKERS WHO MEET REQUIREMENT
LOAD CSV WITH HEADERS FROM 'file:///Site_Meet_Req.csv' AS row

MATCH (worker:siteWorker {workerID: row.workerID})
MATCH (order:Order {orderNo: row.orderNo})
MERGE (worker)-[:Meets_Req]->(order);


//TRANSPORT WORKERS WHO MEET REQUIREMENT
LOAD CSV WITH HEADERS FROM 'file:///Transport_Meet_Req.csv' AS row

MATCH (worker:transportWorker {workerID: row.workerID})
MATCH (order:Order {orderNo: row.orderNo})
MERGE (worker)-[:Meets_Req]->(order);


//DEPOT WORKERS AVAILABLE
LOAD CSV WITH HEADERS FROM 'file:///Depot_Available.csv' AS row

MATCH (worker:depotWorker {workerID: row.workerID})
MATCH (order:Order {orderNo: row.orderNo})
MERGE (worker)-[:Available]->(order);


//SITEWORKERS AVAILABLE
LOAD CSV WITH HEADERS FROM 'file:///Site_Available.csv' AS row

MATCH (worker:siteWorker {workerID: row.workerID})
MATCH (order:Order {orderNo: row.orderNo})
MERGE (worker)-[:Available]->(order);


//TRANSPORT WORKERS AVAILABLE
LOAD CSV WITH HEADERS FROM 'file:///Transport_Available.csv' AS row

MATCH (worker:transportWorker {workerID: row.workerID})
MATCH (order:Order {orderNo: row.orderNo})
MERGE (worker)-[:Available]->(order);


//DEPOT-SITE REALTION
=======
B. IMPORT RELATIONS

//DEPOT SITE RELATION
>>>>>>> main
LOAD CSV WITH HEADERS FROM 'file:///Depot_Site_Relation.csv' AS row

MATCH (worker:depotWorker {workerID: row.workerID})
MATCH (worker2:siteWorker {workerID: row.matchingWorker})
MERGE (worker)-[:Shift_Overlap]->(worker2);

<<<<<<< leroyBranch

//DEPOT-TRANS REALTION
LOAD CSV WITH HEADERS FROM 'file:///Depot_Trans_Relation.csv' AS row

MATCH (worker:depotWorker {workerID: row.workerID})
MATCH (worker2:transportWorker {workerID: row.matchingWorker})
MERGE (worker)-[:Shift_Overlap]->(worker2);

//SITE-TRANS RELATION
LOAD CSV WITH HEADERS FROM 'file:///Site_Trans_Relation.csv' AS row

MATCH (worker:siteWorker {workerID: row.workerID})
MATCH (worker2:transportWorker {workerID: row.matchingWorker})
MERGE (worker)-[:Shift_Overlap]->(worker2);

___________________________________________________________________________________________
MAKING QUERY USING CYPHER

1) Which projects are delayed?

MATCH (p:Project) WHERE p.progress = 'Delayed' 
RETURN p

2) Which orders are impacted by the delayed project?

MATCH (o:Order)-[:ordered_by]-(p:Project) WHERE p.progress = 'Delayed' 
RETURN p,o

3) Which delayed orders have highest priority?

MATCH (p:Project)-[:ordered_by]-(o:Order) WHERE p.progress = 'Delayed' and o.Que = '1'
return p,o

4)What are the options to carry out order with the highest priority

MATCH
    (dp:depotWorker)-[:Available]-(o:Order),
    (dp:depotWorker)-[:Meets_Req]-(o),
    (sw:siteWorker)-[:Available]-(o),
    (sw:siteWorker)-[:Meets_Req]-(o),
    (tw:transportWorker)-[:Available]-(o),
    (tw:transportWorker)-[:Meets_Req]-(o),
    (project:Project)-[]-(sw)
where o.Que = '1'
return dp,sw,tw,o,project

5) What options to carry out order with highest priority and workers are within a 10km traveling distance

MATCH
    (dp:depotWorker)-[:Available]-(o:Order),
    (dp:depotWorker)-[:Meets_Req]-(o),
    (sw:siteWorker)-[:Available]-(o),
    (sw:siteWorker)-[:Meets_Req]-(o),
    (tw:transportWorker)-[:Available]-(o),
    (tw:transportWorker)-[:Meets_Req]-(o),
    (project:Project)-[]-(sw)
where o.Que = '1' AND  project.distance_DK1829B <=10
return dp,sw,tw,o,project
=======
//DEPOT AVAILABLE RELATION
LOAD CSV WITH HEADERS FROM 'file:///Depot_Available.csv' AS row

MATCH (worker:depotWorker {workerID: row.workerID})
MATCH (orderNo:orderNo {orderNo: row.orderNo})
MERGE (worker)-[:Available]->(orderNo);

//DEPOT AVAILABLE RELATION


//DEPOT AVAILABLE RELATION




//DEPOT AVAILABLE RELATION



//DEPOT AVAILABLE RELATION




C. QUERY - SOLUTION GENERATION
>>>>>>> main
